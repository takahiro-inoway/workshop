<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Canvasディフェンスゲーム制作ワークショップ</title>
  <!-- Bulma CDN -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.0/css/bulma.min.css">
  <!-- Highlight.js CDN (Code Highlighting) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <!-- Vue 3 CDN -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <style>
    /* code要素の文字色をBulmaのブルーに変更 */
    code {
      color: #3273dc !important;
      background-color: transparent !important;
      padding: 0 !important;
    }

    /* pre内のcodeはhighlight.jsが色を付けるため、ここでの色指定は除外される */
    pre code {
      color: inherit !important;
    }
  </style>
</head>

<body class="has-background-white has-text-black">
  <div id="app">
    <section class="section">
      <div class="container is-max-desktop">
        <!-- ヘッダー -->
        <div class="has-text-centered mb-6">
          <p>ディフェンスゲーム制作</p>
          <p class="subtitle is-5 has-text-black">CanvasとJavaScriptを使いゲームを完成させます</p>
        </div>

        <hr class="has-background-link">

        <!-- 完成品 -->
        <div class="mb-6">
          <h2 class="title is-4 has-text-link">今回完成させるゲームを実際にプレイ</h2>

          <div class="content has-text-black">
            <p>今回はシンプルなディフェンスゲーム制作を通じて、ゲームプログラムの基本的な処理を学んでいきます</p>
            <p>まずは実際にプレイしてみましょう！</p>
          </div>

          <iframe style="height: 640px; width: 100%;"
            src="https://takahiro-inoway.github.io/workshop/defence_game_1/index.html"></iframe>

        </div>

        <hr class="has-background-link">
        <!-- 1. 振り返り -->
        <div class="columns is-vcentered mb-6">
          <div class="column is-7">
            <h2 class="title is-4 has-text-link">1. HTML / CSS / JavaScript の役割</h2>

            <div class="content">
              <p>Webブラウザ上で動作するプログラムは、主に以下の3つの要素で構成されています。</p>

              <dl>
                <dt class="has-text-weight-bold">
                  <span class="tag is-dark">HTML</span> 構造の定義
                </dt>
                <dd class="mb-3">
                  画面の土台となる部品（キャンバス要素、スコア表示領域、操作用ボタンなど）を配置します。
                </dd>

                <dt class="has-text-weight-bold">
                  <span class="tag is-info">CSS</span> 視覚表現の設定
                </dt>
                <dd class="mb-3">
                  背景色、文字の書式、各部品のサイズやレイアウトなど、外観に関する指定を行います。
                </dd>

                <dt class="has-text-weight-bold">
                  <span class="tag is-warning">JavaScript</span> 動的処理の実装
                </dt>
                <dd>
                  座標計算によるキャラクターの移動、オブジェクト同士の当たり判定、スコアの更新処理などを制御します。
                </dd>
              </dl>
            </div>
          </div>

          <div class="column is-5">
            <div class="box is-paddingless">
              <canvas id="canvas-intro" class="image is-square" style="background-color: #f5f5f5;"></canvas>
            </div>
          </div>
        </div>

        <hr class="has-background-link">

        <!-- 2. HTMLとCSSの実装 -->
        <div class="mb-6">
          <h2 class="title is-4 has-text-link">2. 構造定義（HTML）と視覚設定（CSS）の実装</h2>

          <div class="notification is-light mb-4">
            <div class="content">
              <p>ゲームの実行画面を構成する要素を定義します。動的な制御を行う <code>&lt;script&gt;</code> タグ内は、現段階では未記述（空の状態）とします。</p>
            </div>
          </div>

          <div class="box p-0 is-shadowless" style="border: 1px solid #dbdbdb;">
            <div class="has-background-link-light p-2 px-4 is-flex is-justify-content-between is-align-items-center">
              <span class="is-size-7 has-text-weight-bold has-text-link">index.html</span>
              <span class="tag is-white is-size-7">HTML / CSS</span>
            </div>
            <pre class="p-4 has-background-light has-text-black m-0" style="overflow-x: auto;"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;style&gt;
    /* 全体のレイアウト設定 */
    body {
      margin: 0;
      overflow: hidden;
      background: #1a1a1a;
      font-family: sans-serif;
    }
    canvas {
      display: block;
    }
    /* UI要素（スコア・メッセージ）の配置設定 */
    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      pointer-events: none;
    }
    #msg {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      text-align: center; display: none;
    }
    button { 
      pointer-events: auto;
      padding: 10px 20px;
      cursor: pointer;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="ui"&gt;
      &lt;div&gt;Score: &lt;span id="score"&gt;0&lt;/span&gt;&lt;/div&gt;
      &lt;div&gt;Bullet Size: &lt;span id="bulletSize"&gt;5&lt;/span&gt;&lt;/div&gt;
      &lt;div&gt;Bullet Speed: &lt;span id="bulletSpeed"&gt;5&lt;/span&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;div id="msg"&gt;
    &lt;h1&gt;GAME OVER&lt;/h1&gt;
    &lt;button onclick="resetGame()"&gt;Restart&lt;/button&gt;
  &lt;/div&gt;

  &lt;canvas id="gameCanvas"&gt;&lt;/canvas&gt;

  &lt;script&gt;
    // 今後のステップでロジックを実装します
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
          </div>
        </div>

        <hr class="has-background-link">

        <!-- 3. Canvasの概要 -->
        <div class="columns is-vcentered mb-6">
          <div class="column is-7">
            <h2 class="title is-4 has-text-link">3. Canvas（キャンバス）の仕様</h2>

            <div class="content">
              <p>
                <code>&lt;canvas&gt;</code>
                は、JavaScriptを用いて動的にグラフィックスを描画するためのHTML要素です。Webゲーム開発における描画処理の標準規格として広く利用されています。
              </p>

              <div>
                <div>
                  <p>主な特徴と座標系</p>
                </div>
                <div>
                  <ul>
                    <li>座標管理: 左上端を原点 (0, 0) とし、右方向へ X軸、下方向へ Y軸が増加します。</li>
                    <li>描画機能: 図形（矩形・円）、画像、テキストなどのレンダリングが可能です。</li>
                    <li>リアルタイム性: 高速な書き換えが可能で、アニメーションの実装に適しています。</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <div class="column is-5">
            <div class="card">
              <div class="card-content has-background-light p-2">
                <p class="is-size-7 has-text-centered has-text-grey mb-2">Canvas座標系のイメージ</p>

                <canvas id="canvas-explain" class="image is-square has-background-white"></canvas>
              </div>
            </div>
          </div>
        </div>

        <hr class="has-background-link">

        <!-- 4. getContext -->
        <div class="mb-6">
          <h2 class="title is-4 has-text-link">4. 描画コンテキストの取得</h2>

          <div class="content has-text-black">
            <p>
              JavaScriptからCanvasを操作するには、2つの手順を実行します。まず、HTMLで定義した要素をプログラム内で取得します。次に、その要素から2Dグラフィックスを描画するためのAPI（コンテキスト）を呼び出します。
            </p>
          </div>

          <div class="box p-0 is-shadowless" style="border: 1px solid #dbdbdb;">
            <div class="has-background-white-ter p-2 px-4 border-bottom">
              <p class="is-size-7 has-text-black">JavaScript</p>
            </div>
            <pre class="p-4 has-background-light has-text-black m-0"><code class="language-javascript">// IDを指定してCanvas要素を取得
const canvas = document.getElementById('gameCanvas');

// 2D描画用API（コンテキスト）を取得
const ctx = canvas.getContext('2d');</code></pre>
          </div>
        </div>

        <hr class="has-background-link">

        <!-- 5. 数値の定義 -->
        <div class="mb-6">
          <h2 class="title is-4 has-text-link">5. 変数と定数の定義</h2>

          <div class="content has-text-black">
            <p>
              ゲームの状態を保持する変数と、プログラム全体で使用する固定値を定義します。
              スコアや進行状況を管理する数値、複数のオブジェクトを格納するための配列、および動作の基準となる定数値を設定します。
            </p>
          </div>

          <div class="box p-0 is-shadowless" style="border: 1px solid #dbdbdb;">
            <div class="has-background-white-ter p-2 px-4 border-bottom">
              <p class="is-size-7 has-text-black">JavaScript</p>
            </div>
            <pre class="p-4 has-background-light has-text-black m-0"><code class="language-javascript">// ゲームの進行状況を管理する変数
let score = 0;
let gameOver = false;
let enemies = [];
let bullets = [];
let mouse = { x: 0, y: 0 };

// 描画および計算に使用する定数
const PLAYER_RADIUS = 30; // プレイヤーの半径
const ENEMY_SPEED = 0.5;   // 敵の移動速度
const BULLET_RADIUS = 5;  // 弾の半径
const BULLET_SPEED = 5;   // 弾の移動速度</code></pre>
          </div>
          <div class="content has-text-black">
            <p>JavaScriptにおけるconstとletの決定的な違いは、**「一度入れた値を、後から入れ直せるかどうか」**という点です。
              <br>
              <br>
              <b>1. const（定数）</b>
              <br>
              「定まった数」という名前の通り、一度値を決めたら変更できません。
              <br>
              再代入が禁止： const name = "田中"; と決めた後に name = "佐藤"; と書き換えることはできず、エラーになります。
              <br>
              <b>使いどころ： プログラムの中で途中で変わってほしくない値や、名前、設定値などに使います。</b>
              <br>
              <br>
              <b>2. let（変数）</b>
              <br>
              「変化する数」として、後から何度でも値を入れ直すことができます。
              <br>
              再代入が可能： let score = 0; としておき、後から score = 100; と書き換えることができます。
              <br>
              <b>使いどころ： 計算の途中で合計値が変わる場合や、繰り返しの回数を数えるときなど、値が変わる必要がある場合に使います。</b>
            </p>
          </div>
        </div>

        <hr class="has-background-link">

        <!-- 6. resize -->
        <div class="mb-6">
          <h2 class="title is-4 has-text-link">6. 画面サイズへの対応</h2>
          <div class="content">
            <p>ブラウザのサイズが変更されたとき、キャンバスの大きさも自動で調整されるようにします。また、マウスの動きとクリックを感知する設定も追加します。</p>
          </div>
          <div class="box p-0 is-shadowless" style="border: 1px solid #dbdbdb;">
            <div class="has-background-white-ter p-2 px-4 border-bottom">
              <p class="is-size-7 has-text-black">JavaScript</p>
            </div>
            <pre class="p-4 has-background-light has-text-black m-0"><code class="language-javascript">function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('mousedown', spawnBullet);
resize();</code></pre>
          </div>
        </div>

        <hr class="has-background-link">

        <!-- 7. spawnBullet -->
        <div class="columns is-vcentered mb-6">
          <div class="column is-7">
            <h2 class="title is-4 has-text-link">7. 弾の生成処理（spawnBullet）</h2>
            <div class="content has-text-black">
              <p>
                マウス座標と画面中心座標から逆正接関数（Math.atan2）を用いて射出角度を算出します。
                算出した角度に基づき、弾の初期位置と速度成分（x, y）をオブジェクトとして定義し、<code>bullets</code> 配列に追加します。
                これにより、画面上の複数の弾を配列の要素として個別に制御します。
              </p>
            </div>
          </div>
          <div class="column is-5">
            <div class="box p-1 has-background-grey-lighter">
              <p class="is-size-7 has-text-black has-text-centered mb-1">射出角度と速度の計算イメージ</p>

              <canvas id="canvas-bullet" class="image is-square has-background-white"></canvas>
            </div>
          </div>
        </div>

        <div class="box p-0 is-shadowless" style="border: 1px solid #dbdbdb;">
          <div class="has-background-white-ter p-2 px-4 border-bottom">
            <p class="is-size-7 has-text-black">JavaScript / spawnBullet関数</p>
          </div>
          <pre class="p-4 has-background-light has-text-black m-0"><code class="language-javascript">function spawnBullet() {
  if (gameOver) return;

  // 中心点からマウスへの角度を算出
  const angle = Math.atan2(mouse.y - canvas.height / 2, mouse.x - canvas.width / 2);

  // 新規オブジェクトを配列に追加
  bullets.push({
    x: canvas.width / 2 + Math.cos(angle) * PLAYER_RADIUS, // 出現位置x
    y: canvas.height / 2 + Math.sin(angle) * PLAYER_RADIUS, // 出現位置y
    vx: Math.cos(angle) * BULLET_SPEED,                    // x軸の速度
    vy: Math.sin(angle) * BULLET_SPEED                     // y軸の速度
  });
}</code></pre>
        </div>

        <hr class="has-background-link">

        <!-- 8. animate -->
        <div class="mb-6">
          <h2 class="title is-4 has-text-link">8. 描画ループの制御（animate関数）</h2>

          <div class="content has-text-black">
            <p>
              <code>requestAnimationFrame</code> を用いて <code>animate</code> 関数を再帰的に実行し、画面を逐次更新します。
              この処理では、直前のフレームの消去、マウス方向への角度計算と線画（砲身）、および配列内に存在する各弾の移動計算と描画を連続して行います。
            </p>
          </div>

          <div class="box p-0 is-shadowless" style="border: 1px solid #dbdbdb;">
            <div class="has-background-white-ter p-2 px-4 border-bottom">
              <p class="is-size-7 has-text-black">JavaScript / 描画および更新処理</p>
            </div>
            <pre class="p-4 has-background-light has-text-black m-0" style="overflow-x: auto;"><code class="language-javascript">function animate() {
  if (gameOver) return;
  // 次のフレームの描画を予約
  requestAnimationFrame(animate);
  
  // 画面の消去（半透明の塗りで残像効果を付与）
  ctx.fillStyle = 'rgba(26, 26, 26, 0.3)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const cx = canvas.width / 2;
  const cy = canvas.height / 2;

  // マウスの方向に合わせた砲身の描画
  const angle = Math.atan2(mouse.y - cy, mouse.x - cx);
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx + Math.cos(angle) * 45, cy + Math.sin(angle) * 45);
  ctx.strokeStyle = '#3273dc';
  ctx.stroke();

  // 各弾の移動更新と描画
  bullets.forEach((b, bi) => {
    b.x += b.vx; // 速度成分を加算して位置を更新
    b.y += b.vy;
    
    ctx.beginPath();
    ctx.arc(b.x, b.y, BULLET_RADIUS, 0, Math.PI * 2);
    ctx.fillStyle = '#ffcc00';
    ctx.fill();

    // 画面外に出た弾を配列から削除
    if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
      bullets.splice(bi, 1);
    }
  });
}</code></pre>
          </div>
        </div>

        <hr class="has-background-link">

        <!-- 9. resetGame -->
        <div class="mb-6">
          <h2 class="title is-4 has-text-link">9. ゲーム状態の初期化（resetGame）</h2>
          <div class="content">
            <p>ゲームを最初から始めるために、スコアや配列の中身を空に戻します。<code>animate()</code> を実行することで、描画ループが開始されます。</p>
          </div>
          <pre class="p-4 has-background-light has-text-black"><code class="language-javascript">function resetGame() {
  score = 0;
  enemies = [];
  bullets = [];
  gameOver = false;
  document.getElementById('score').textContent = score;
  document.getElementById('msg').style.display = 'none';
  
  animate();
}

resetGame()
</code></pre>
          <div class="notification is-info is-light mt-3">
            <p><strong>なぜここで spawnEnemy を呼ぶのか？</strong></p>
            <p><code>resetGame</code>
              は「ゲームの開始地点」です。ここで一度呼ぶことで、敵の生成という「終わりのないループ（タイマー）」に火をつけます。一度動き出せば、関数の中で自分自身をまた呼び出す（再帰）ため、二度呼ぶ必要はありません。</p>
          </div>
        </div>

        <!-- 実行確認 -->
        <div class="mb-6">
          <h2 class="title is-4 has-text-black">実行してみよう！デバッグタイム</h2>
          <div class="content">
            <p>デバッグをしてみましょう！思い通りに動かない場合は、以下のステップでデバッグしましょう。</p>
            <ul>
              <li><span class="button is-link">コンソールを確認</span> F12キーで開発者ツールを開き、Consoleタブに赤いエラーが出ていないか？</li>
              <li><span class="button is-link">スペルミス</span> <code>canvas</code> が <code>canvas</code> になっているか？
                <code>ctx</code> が
                <code>context</code> になっていないか？
              </li>
              <li><span class="button is-link">カッコの対応</span> <code>{</code> に対応する <code>}</code> が抜けていないか？</li>
            </ul>
          </div>
        </div>

        <hr class="has-background-link">

        <!-- 10. 敵の考察 -->
        <div class="columns is-vcentered mb-6">
          <div class="column is-7">
            <h2 class="title is-4 has-text-link">10. 敵の実装理論</h2>
            <div class="content">
              <p>敵を追加するために必要な理論を整理します。</p>
              <ul>
                <li><code>Math.random()</code>: 0以上1未満のランダムな数字を作ります。これに出現させたい範囲を掛け算して、敵の位置をバラバラにします。</li>
                <li><code>setTimeout(関数, 時間)</code>: 指定したミリ秒（1秒=1000）後に一度だけ関数を実行します。</li>
              </ul>
            </div>
          </div>
          <div class="column is-5">
            <canvas id="canvas-enemy-logic" class="image is-square"></canvas>
          </div>
        </div>

        <hr class="has-background-link">

        <!-- 11. spawnEnemy -->
        <div class="mb-6">
          <h2 class="title is-4 has-text-link">11. 敵の出現処理（spawnEnemy）の実装</h2>
          <div class="content">
            <p>画面外のランダムな位置に敵データを生成し、配列に追加します。最後に自分自身をまたタイマーにかけることで、敵が無限に出現し続ける仕組みを作ります。</p>
          </div>
          <pre class="p-4 has-background-light has-text-black"><code class="language-javascript">function spawnEnemy() {
  if (gameOver) return; // ゲームオーバーなら次を予約しない

  const angle = Math.random() * Math.PI * 2; // 360度ランダムな方向
  const dist = Math.max(canvas.width, canvas.height); // 画面の外側

  enemies.push({
    x: canvas.width / 2 + Math.cos(angle) * dist,
    y: canvas.height / 2 + Math.sin(angle) * dist,
    r: 10 + Math.random() * 10 // 大きさもランダム
  });

  // 次の敵が出るまでの時間（スコアが上がると早くなる）
  const nextTime = Math.max(500, 2000 - score * 10);
  setTimeout(spawnEnemy, nextTime);
}</code></pre>
          <div class="content">
            <p>さらに、リセット時にも実行されるようにresetGame()に追記します。</p>
          </div>
          <pre class="p-4 has-background-light has-text-black"><code class="language-javascript">function resetGame() {
  score = 0;
  enemies = [];
  bullets = [];
  gameOver = false;
  document.getElementById('score').textContent = score;
  document.getElementById('msg').style.display = 'none';
  
  animate();
  spawnEnemy(); // ★追加: ゲーム開始時に敵の生成ループを開始
}

resetGame()
</code></pre>

        </div>

        <hr class="has-background-link">

        <!-- 12. 衝突判定 -->
        <div class="columns is-vcentered mb-6">
          <div class="column is-7">
            <h2 class="title is-4 has-text-link">12. 衝突判定の仕組みと実装</h2>
            <div class="content">
              <p>「当たり」をどう判定するか？ Canvasの世界では円の衝突は数学で解けます。</p>
              <p><span class="button is-link">判定方法</span>2つの円の中心点の距離が、それぞれの「半径の合計」よりも短くなれば、それは「重なっている（衝突している）」ということです。
              </p>
            </div>
          </div>
          <div class="column is-5">
            <canvas id="canvas-collision" class="image is-square"></canvas>
          </div>
        </div>
        <div class="mb-6">
          <div class="content">
            <p><code>animate</code> 関数内の <code>bullets.forEach</code> のすぐ下に、敵の更新と衝突判定のコードを追加します。</p>
          </div>
          <pre class="p-4 has-background-light has-text-black"><code class="language-javascript">// animate関数内に追加する処理
enemies.forEach((e, ei) => {
  const dx = canvas.width / 2 - e.x;
  const dy = canvas.height / 2 - e.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  // 中心に向かって移動
  e.x += (dx / dist) * ENEMY_SPEED;
  e.y += (dy / dist) * ENEMY_SPEED;

  // 敵の描画
  ctx.beginPath();
  ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
  ctx.fillStyle = '#ff4444';
  ctx.fill();

  // プレイヤー（拠点）との衝突
  if (dist < PLAYER_RADIUS + e.r) {
    gameOver = true;
    document.getElementById('msg').style.display = 'block';
  }

  // 弾との衝突判定
  bullets.forEach((b, bi) => {
    const bdx = b.x - e.x;
    const bdy = b.y - e.y;
    const b_dist = Math.sqrt(bdx * bdx + bdy * bdy);
    if (b_dist < BULLET_RADIUS + e.r) {
      enemies.splice(ei, 1);
      bullets.splice(bi, 1);
      score += 10;
      document.getElementById('score').textContent = score;
    }
  });
});</code></pre>
        </div>

        <hr class="has-background-link">

        <!-- 13. 最終実行 -->
        <div class="notification is-link is-light mb-6">
          <h2 class="title is-4 has-text-black">13. すべての実行が完了しました！</h2>
          <div class="content">
            <p>これでゲームのすべての機能が実装されました。HTMLファイルを保存してブラウザでリフレッシュしてください。迫りくる赤い敵を青い砲台で撃退できれば成功です！</p>
          </div>
        </div>

        <hr class="has-background-link">

        <!-- 実行確認 -->
        <div class="mb-6">
          <h2 class="title is-4 has-text-black">実行してみよう！デバッグタイム</h2>
          <div class="content">
            <p>デバッグをしてみましょう！思い通りに動かない場合は、以下のステップでデバッグしましょう。</p>
            <ul>
              <li><span class="button is-link">コンソールを確認</span> F12キーで開発者ツールを開き、Consoleタブに赤いエラーが出ていないか？</li>
              <li><span class="button is-link">スペルミス</span> <code>canvas</code> が <code>canvas</code> になっているか？
                <code>ctx</code> が
                <code>context</code> になっていないか？
              </li>
              <li><span class="button is-link">カッコの対応</span> <code>{</code> に対応する <code>}</code> が抜けていないか？</li>
            </ul>
          </div>
        </div>

        <hr class="has-background-link">

        <!-- 最終確認 -->
        <div class="mb-6">
          <h2 class="title is-4 has-text-link">13. 最終確認</h2>
          <div class="content">
            <p>Scriptタグ内の最終的な完成形を示します。自分のコードと見比べてうまく動作しない箇所を見つけて修正して完成させましょう</p>
          </div>
          <pre class="p-4 has-background-light has-text-black"><code class="language-javascript">// scriptタグ内のJavaScript全文
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let score = 0;
    let gameOver = false;
    let enemies = [];
    let bullets = [];
    let mouse = { x: 0, y: 0 };

    const PLAYER_RADIUS = 30;
    const ENEMY_SPEED = 0.5;
    const BULLET_RADIUS = 30;
    const BULLET_SPEED = 5;

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resize);
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mousedown', spawnBullet);
    resize();

    function spawnBullet() {
      if (gameOver) return;
      const angle = Math.atan2(mouse.y - canvas.height / 2, mouse.x - canvas.width / 2);
      bullets.push({
        x: canvas.width / 2 + Math.cos(angle) * PLAYER_RADIUS,
        y: canvas.height / 2 + Math.sin(angle) * PLAYER_RADIUS,
        vx: Math.cos(angle) * BULLET_SPEED,
        vy: Math.sin(angle) * BULLET_SPEED
      });
    }

    function spawnEnemy() {
      if (gameOver) return;
      const angle = Math.random() * Math.PI * 2;
      const dist = Math.max(canvas.width, canvas.height);
      enemies.push({
        x: canvas.width / 2 + Math.cos(angle) * dist,
        y: canvas.height / 2 + Math.sin(angle) * dist,
        r: 10 + Math.random() * 10
      });
      setTimeout(spawnEnemy, Math.max(500, 2000 - score * 10));
    }

    function animate() {
      if (gameOver) return;
      requestAnimationFrame(animate);
      ctx.fillStyle = 'rgba(26, 26, 26, 0.3)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const cx = canvas.width / 2;
      const cy = canvas.height / 2;

      // 拠点（中央の円）
      ctx.beginPath();
      ctx.arc(cx, cy, PLAYER_RADIUS, 0, Math.PI * 2);
      ctx.strokeStyle = '#00ffcc';
      ctx.lineWidth = 3;
      ctx.stroke();

      // 砲台
      const angle = Math.atan2(mouse.y - cy, mouse.x - cx);
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(angle) * 45, cy + Math.sin(angle) * 45);
      ctx.strokeStyle = '#ff3366';
      ctx.stroke();

      // 弾の更新
      bullets.forEach((b, bi) => {
        b.x += b.vx;
        b.y += b.vy;
        ctx.beginPath();
        ctx.arc(b.x, b.y, BULLET_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = '#ffcc00';
        ctx.fill();
        if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) bullets.splice(bi, 1);
      });

      // 敵の更新
      enemies.forEach((e, ei) => {
        const dx = cx - e.x;
        const dy = cy - e.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        e.x += (dx / dist) * ENEMY_SPEED;
        e.y += (dy / dist) * ENEMY_SPEED;

        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
        ctx.fillStyle = '#ff4444';
        ctx.fill();

        // 衝突判定（拠点）
        if (dist < PLAYER_RADIUS + e.r) {
          gameOver = true;
          document.getElementById('msg').style.display = 'block';
        }

        // 衝突判定（弾）
        bullets.forEach((b, bi) => {
          const bdx = b.x - e.x;
          const bdy = b.y - e.y;
          const b_dist = Math.sqrt(bdx * bdx + bdy * bdy);
          if (b_dist < BULLET_RADIUS + e.r) {
            enemies.splice(ei, 1);
            bullets.splice(bi, 1);
            score += 10;
            document.getElementById('score').textContent = score;
          }
        });
      });
    }


    function resetGame() {
      score = 0;
      enemies = [];
      bullets = [];
      gameOver = false;
      document.getElementById('score').textContent = score;
      document.getElementById('msg').style.display = 'none';
      spawnEnemy();
      animate();
    }

    resetGame();</code></pre>
        </div>

        <hr class="has-background-link">

        <!-- アレンジ -->
        <div class="mb-6">
          <h2 class="title is-4 has-text-link">14. アレンジ</h2>
          <div class="content">
            <p>定義部分の数字を変更したり、各箇所の色を変更してオリジナリティのある作品にしあげよう！</p>
            <p>まだ変数化されていないパラメータ（大きさや色、速度など）があれば変数化して自由に変更できるようにしてみよう！</p>
          </div>
        </div>
        <pre class="p-4 has-background-light has-text-black"><code class="language-javascript">// 定義の部分
    let score = 0;
    let gameOver = false;
    let enemies = [];
    let bullets = [];
    let mouse = { x: 0, y: 0 };

    const PLAYER_RADIUS = 30;
    const ENEMY_SPEED = 0.5;
    const BULLET_RADIUS = 30;
    const BULLET_SPEED = 5;</code></pre>

        <hr class="has-background-link">

        <footer class="footer has-background-white p-6 border-top">
          <div class="content has-text-centered">
            <p class="has-text-grey">ディフェンスゲーム制作ワークショップ - 終了</p>
          </div>
        </footer>
      </div>
    </section>
  </div>

  <script>
    const { createApp, onMounted } = Vue;

    createApp({
      setup() {
        onMounted(() => {
          // Highlight.jsの初期化
          hljs.highlightAll();

          const canvases = [
            { id: 'canvas-intro', draw: drawIntro },
            { id: 'canvas-explain', draw: drawExplain },
            { id: 'canvas-bullet', draw: drawBullet },
            { id: 'canvas-enemy-logic', draw: drawEnemyLogic },
            { id: 'canvas-collision', draw: drawCollision }
          ];

          canvases.forEach(item => {
            const c = document.getElementById(item.id);
            if (!c) return;
            // 正方形を保つための設定
            const size = 300;
            c.width = size;
            c.height = size;
            const ctx = c.getContext('2d');
            item.draw(ctx, size);
          });
        });

        const drawIntro = (ctx, s) => {
          ctx.fillStyle = "#3273dc";
          ctx.font = "bold 18px sans-serif";
          ctx.fillRect(s * 0.1, s * 0.4, s * 0.2, s * 0.2); ctx.fillText("HTML", s * 0.1, s * 0.35);
          ctx.strokeStyle = "#000"; ctx.lineWidth = 2;
          ctx.strokeRect(s * 0.4, s * 0.4, s * 0.2, s * 0.2); ctx.fillText("CSS", s * 0.43, s * 0.35);
          ctx.beginPath(); ctx.arc(s * 0.8, s * 0.5, s * 0.1, 0, Math.PI * 2); ctx.fill(); ctx.fillText("JS", s * 0.78, s * 0.35);
        };

        const drawExplain = (ctx, s) => {
          ctx.strokeStyle = "#000"; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.moveTo(s * 0.1, s * 0.1); ctx.lineTo(s * 0.1, s * 0.9); ctx.lineTo(s * 0.9, s * 0.9); ctx.stroke();
          ctx.font = "14px sans-serif";
          ctx.fillText("(0, 0)", s * 0.12, s * 0.15);
          ctx.fillText("X軸 →", s * 0.7, s * 0.85);
          ctx.fillText("Y軸 ↓", s * 0.12, s * 0.8);
          ctx.fillStyle = "#3273dc";
          ctx.fillRect(s * 0.4, s * 0.4, s * 0.2, s * 0.2);
        };

        const drawBullet = (ctx, s) => {
          const cx = s / 2, cy = s / 2;
          ctx.strokeStyle = "#000"; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(cx, cy, s * 0.1, 0, Math.PI * 2); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + s * 0.2, cy - s * 0.2); ctx.stroke();
          ctx.fillStyle = "#ffcc00"; ctx.beginPath(); ctx.arc(cx + s * 0.25, cy - s * 0.25, 8, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = "#000"; ctx.font = "14px sans-serif";
          ctx.fillText("計算した角度に飛ばす", s * 0.1, s * 0.9);
        };

        const drawEnemyLogic = (ctx, s) => {
          const cx = s / 2, cy = s / 2;
          ctx.strokeStyle = "#000"; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(cx, cy, s * 0.1, 0, Math.PI * 2); ctx.stroke();
          ctx.fillStyle = "#ff4444"; ctx.beginPath(); ctx.arc(s * 0.2, s * 0.2, 15, 0, Math.PI * 2); ctx.fill();
          ctx.setLineDash([5, 5]);
          ctx.beginPath(); ctx.moveTo(s * 0.2, s * 0.2); ctx.lineTo(cx - s * 0.05, cy - s * 0.05); ctx.stroke();
          ctx.setLineDash([]);
          ctx.fillStyle = "#000"; ctx.fillText("画面外 → 中心点", s * 0.1, s * 0.9);
        };

        const drawCollision = (ctx, s) => {
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(s * 0.35, s * 0.4, s * 0.15, 0, Math.PI * 2); ctx.strokeStyle = "#000"; ctx.stroke();
          ctx.beginPath(); ctx.arc(s * 0.6, s * 0.4, s * 0.1, 0, Math.PI * 2); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(s * 0.35, s * 0.4); ctx.lineTo(s * 0.6, s * 0.4); ctx.strokeStyle = "#3273dc"; ctx.stroke();
          ctx.fillStyle = "#000"; ctx.font = "12px sans-serif";
          ctx.fillText("中心の距離 < 半径の合計", s * 0.2, s * 0.8);
        };

        return {};
      }
    }).mount('#app');
  </script>
</body>

</html>