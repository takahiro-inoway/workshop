<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Object Detection</title>
  <!-- Bulma CSS for styling -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css">
  <!-- Vue.js for reactivity -->
  <script src="https://cdn.jsdelivr.net/npm/vue@3.2.31/dist/vue.global.js"></script>
  <!-- TensorFlow.js and COCO-SSD model -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
  <style>
    /* グローバルスタイル */
    body {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }

    /* ビデオとキャンバスのコンテナ */
    .video-container {
      position: relative;
      background: #000;
      border-radius: 8px;
      overflow: hidden;
      /* ビデオのアスペクト比を維持 */
      display: inline-block;
      max-width: 100%;
      width: 100%;
    }

    /* ビデオ要素 */
    #videoElement {
      display: block;
      width: 100%;
      height: auto;
    }

    /* キャンバス要素 */
    #canvasElement {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      /* クリックイベントを透過させる */
    }

    /* FPSカウンター */
    .fps-counter {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: #00d1b2;
      padding: 0.5rem;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.8rem;
    }

    /* ガラス風カード */
    .glass-card {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    /* 統計情報のグリッドレイアウト */
    .stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.5rem;
    }

    /* 検出リストのスクロールエリア */
    .detection-list {
      max-height: 200px;
      overflow-y: auto;
    }

    /* 信頼度バー */
    .confidence-bar {
      width: 50px;
      height: 4px;
      background: #e9ecef;
      border-radius: 2px;
      overflow: hidden;
    }

    /* 信頼度バーの塗りつぶし */
    .confidence-fill {
      height: 100%;
      background: #00d1b2;
      transition: width 0.3s ease;
    }
  </style>
</head>

<body>
  <div id="app">
    <section class="hero is-fullheight">
      <div class="hero-body">
        <div class="container">
          <div class="columns is-centered">
            <div class="column is-10">
              <!-- ヘッダー -->
              <div class="has-text-centered mb-5">
                <h1 class="title is-2 has-text-white">AI Object Detection</h1>
                <p class="subtitle has-text-white-ter">リアルタイム物体認識</p>
              </div>

              <!-- メインカード -->
              <div class="card glass-card">
                <!-- ステータス -->
                <div class="card-header has-background-primary">
                  <p class="card-header-title has-text-white has-text-centered is-size-6">
                    {{ status }}
                  </p>
                </div>

                <div class="card-content">
                  <!-- ビデオエリア -->
                  <div class="video-container mb-4">
                    <!-- ビデオ要素 -->
                    <video id="videoElement" ref="video" autoplay muted playsinline></video>
                    <!-- キャンバス要素 -->
                    <canvas id="canvasElement" ref="canvas"></canvas>
                    <!-- FPSカウンター -->
                    <div v-if="isDetecting" class="fps-counter">
                      FPS: {{ fps }}
                    </div>
                  </div>

                  <!-- コントロールボタン -->
                  <div class="buttons is-centered mb-4">
                    <button @click="startDetection" :disabled="isDetecting || !modelLoaded"
                      class="button is-primary is-medium">
                      {{ isDetecting ? '検出中...' : '検出開始' }}
                    </button>
                    <button @click="stopDetection" :disabled="!isDetecting" class="button is-danger is-medium">
                      停止
                    </button>
                  </div>

                  <!-- 統計情報 -->
                  <div class="stat-grid mb-4">
                    <div class="box has-text-centered">
                      <p class="title is-4 has-text-primary">{{ totalDetections }}</p>
                      <p class="subtitle is-6">総検出数</p>
                    </div>
                    <div class="box has-text-centered">
                      <p class="title is-4 has-text-primary">{{ uniqueObjects.size }}</p>
                      <p class="subtitle is-6">物体種類</p>
                    </div>
                    <div class="box has-text-centered">
                      <p class="title is-4 has-text-primary">{{ currentDetections.length }}</p>
                      <p class="subtitle is-6">現在検出</p>
                    </div>
                    <div class="box has-text-centered">
                      <p class="title is-4 has-text-primary">{{ Math.round(averageConfidence * 100) }}%</p>
                      <p class="subtitle is-6">平均信頼度</p>
                    </div>
                  </div>

                  <!-- 検出リスト -->
                  <div v-if="currentDetections.length > 0" class="box detection-list">
                    <h5 class="subtitle is-6 mb-3">現在検出中の物体</h5>
                    <div v-for="detection in currentDetections" :key="detection.class" class="level is-mobile mb-2">
                      <div class="level-left">
                        <span class="tag is-light">{{ detection.class }}</span>
                      </div>
                      <div class="level-right">
                        <span class="has-text-grey mr-2">{{ Math.round(detection.score * 100) }}%</span>
                        <div class="confidence-bar">
                          <div class="confidence-fill" :style="{ width: (detection.score * 100) + '%' }"></div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
    const { createApp, ref, onMounted, onUnmounted, computed } = Vue;

    createApp({
      setup() {
        const video = ref(null);
        const canvas = ref(null);
        const isDetecting = ref(false);
        const modelLoaded = ref(false);
        const status = ref('準備中...');
        const currentDetections = ref([]);
        const totalDetections = ref(0);
        const uniqueObjects = ref(new Set());
        const fps = ref(0);

        let model = null;
        let animationId = null;
        let lastTime = 0;
        let frameCount = 0;

        const averageConfidence = computed(() => {
          if (currentDetections.value.length === 0) return 0;
          const sum = currentDetections.value.reduce((acc, det) => acc + det.score, 0);
          return sum / currentDetections.value.length;
        });

        onMounted(async () => {
          await loadModel();
        });

        onUnmounted(() => {
          stopDetection();
        });

        // AIモデルを読み込む
        const loadModel = async () => {
          try {
            status.value = 'AIモデル読み込み中...';
            model = await cocoSsd.load();
            modelLoaded.value = true;
            status.value = '準備完了！検出を開始してください';
          } catch (error) {
            console.error('モデル読み込みエラー:', error);
            status.value = 'エラー: モデルを読み込めませんでした';
          }
        };

        // カメラを起動する
        const startCamera = async () => {
          try {
            status.value = 'カメラ起動中...';
            const stream = await navigator.mediaDevices.getUserMedia({
              video: {
                facingMode: 'environment',
                width: { ideal: 640 },
                height: { ideal: 480 }
              }
            });

            video.value.srcObject = stream;
            // onloadedmetadata イベントではなく、play() プロミスが解決した後に検出を開始する
            video.value.play().then(() => {
              // ビデオのネイティブ解像度を取得して、キャンバスのサイズを同期
              const videoWidth = video.value.videoWidth;
              const videoHeight = video.value.videoHeight;
              canvas.value.width = videoWidth;
              canvas.value.height = videoHeight;

              // キャンバスのスタイルも同期
              canvas.value.style.width = video.value.offsetWidth + 'px';
              canvas.value.style.height = video.value.offsetHeight + 'px';

              // カメラが起動したら物体検出を開始
              startObjectDetection();
            }).catch(error => {
              console.error('ビデオ再生エラー:', error);
              status.value = 'エラー: ビデオを再生できませんでした';
              isDetecting.value = false;
            });
          } catch (error) {
            console.error('カメラエラー:', error);
            status.value = 'エラー: カメラにアクセスできませんでした';
            isDetecting.value = false;
          }
        };

        // 物体検出を開始
        const startObjectDetection = () => {
          isDetecting.value = true;
          status.value = 'リアルタイム検出中...';
          lastTime = performance.now();
          frameCount = 0;
          detectFrame();
        };

        // フレームごとに物体を検出
        const detectFrame = async () => {
          if (!isDetecting.value || video.value.readyState < 2) {
            if (isDetecting.value) {
              animationId = requestAnimationFrame(detectFrame);
            }
            return;
          }

          // FPS計算
          const currentTime = performance.now();
          frameCount++;
          if (currentTime - lastTime >= 1000) {
            fps.value = Math.round((frameCount * 1000) / (currentTime - lastTime));
            frameCount = 0;
            lastTime = currentTime;
          }

          try {
            const predictions = await model.detect(video.value);
            currentDetections.value = predictions;

            // 検出数を更新
            if (predictions.length > 0) {
              totalDetections.value += predictions.length;
            }

            // 種類を更新
            predictions.forEach(pred => {
              uniqueObjects.value.add(pred.class);
            });

            // バウンディングボックスを描画
            drawBoundingBoxes(predictions);
          } catch (error) {
            console.error('検出エラー:', error);
          }

          animationId = requestAnimationFrame(detectFrame);
        };

        // バウンディングボックスを描画
        const drawBoundingBoxes = (predictions) => {
          const ctx = canvas.value.getContext('2d');

          // 前のフレームをクリア
          ctx.clearRect(0, 0, canvas.value.width, canvas.value.height);

          const colors = ['#00d1b2', '#3273dc', '#ff3860', '#ffdd57', '#00c4a7'];

          predictions.forEach((pred, i) => {
            const [x, y, width, height] = pred.bbox;
            const color = colors[i % colors.length];
            const confidence = Math.round(pred.score * 100);

            // バウンディングボックスを描画
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.strokeRect(x, y, width, height);

            // ラベルのテキストと背景
            const text = `${pred.class} ${confidence}%`;
            ctx.font = '16px sans-serif';
            const textWidth = ctx.measureText(text).width;
            const labelY = y > 25 ? y - 5 : y + height + 20;

            // 背景
            ctx.fillStyle = color;
            ctx.fillRect(x, labelY - 20, textWidth + 10, 25);

            // テキスト
            ctx.fillStyle = '#ffffff';
            ctx.fillText(text, x + 5, labelY - 5);
          });
        };

        // 検出を停止
        const stopDetection = () => {
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }

          if (video.value && video.value.srcObject) {
            video.value.srcObject.getTracks().forEach(track => track.stop());
            video.value.srcObject = null;
          }

          if (canvas.value) {
            const ctx = canvas.value.getContext('2d');
            ctx.clearRect(0, 0, canvas.value.width, canvas.value.height);
          }

          isDetecting.value = false;
          currentDetections.value = [];
          fps.value = 0;
          status.value = '検出を停止しました';
        };

        // 検出開始ボタンのハンドラ
        const startDetection = async () => {
          if (isDetecting.value || !modelLoaded.value) return;

          totalDetections.value = 0;
          uniqueObjects.value = new Set();
          currentDetections.value = [];

          await startCamera();
        };

        return {
          video,
          canvas,
          isDetecting,
          modelLoaded,
          status,
          currentDetections,
          totalDetections,
          uniqueObjects,
          fps,
          averageConfidence,
          startDetection,
          stopDetection
        };
      }
    }).mount('#app');
  </script>
</body>

</html>