<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ドット絵配列ジェネレーター (マルチカラー)</title>
  <!-- Tailwind CSSを読み込み -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* カスタムスタイル：ドットのグリッド */
    .dot-grid {
      display: grid;
      border: 1px solid #374151;
      /* グリッド全体の枠 */
      user-select: none;
      /* 選択を無効化 */
      touch-action: none;
      /* タッチ操作を滑らかに */
      cursor: crosshair;
    }

    .dot-cell {
      aspect-ratio: 1 / 1;
      /* 正方形を維持 */
      background-color: #f3f4f6;
      /* 色0 (未描画)の基本色 */
      transition: background-color 0.1s ease;
      /* グリッド線 */
      border: 1px solid #d1d5db;
    }

    /* data-color属性に基づいて背景色を設定 */

    /* 色0: 消しゴム / 背景 (薄いグレー) */
    .dot-cell[data-color="0"] {
      background-color: #f3f4f6;
    }

    /* 色1: 黒 (デフォルト色) */
    .dot-cell[data-color="1"] {
      background-color: #1f2937;
    }

    /* 色2: 赤 */
    .dot-cell[data-color="2"] {
      background-color: #ef4444;
    }

    /* 色3: 青 */
    .dot-cell[data-color="3"] {
      background-color: #3b82f6;
    }
  </style>
</head>

<body class="bg-gray-100 min-h-screen p-4 md:p-8 font-sans flex justify-center">

  <div id="app" class="w-full max-w-4xl bg-white shadow-xl rounded-xl p-6 space-y-6">
    <header class="text-center pb-4 border-b">
      <h1 class="text-3xl font-bold text-gray-800">ドット絵配列ジェネレーター</h1>
      <p class="text-gray-500 mt-1">グリッドをクリックしてマルチカラードット絵を作成し、二次元配列に変換します。</p>
    </header>

    <!-- コントロールパネル -->
    <div class="flex flex-col space-y-4">
      <!-- グリッドサイズ設定 -->
      <div class="flex-grow flex items-center bg-gray-50 p-3 rounded-lg shadow-inner">
        <label for="grid-size" class="text-sm font-medium text-gray-700 mr-3">サイズ (N x N):</label>
        <input type="number" id="grid-size" value="8" min="4" max="32"
          class="w-20 p-2 border border-gray-300 rounded-lg text-center focus:ring-blue-500 focus:border-blue-500" />
        <button id="set-size-btn"
          class="ml-3 px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
          サイズ変更
        </button>
      </div>

      <!-- カラー選択とクリアボタン -->
      <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4">
        <!-- カラー設定と選択 -->
        <div class="flex-grow bg-gray-50 p-3 rounded-lg shadow-inner">
          <h2 class="text-lg font-semibold text-gray-700 mb-2">色の設定</h2>
          <div id="color-controls" class="space-y-4">
            <!-- 色の選択ボタンと入力フィールドがここに動的に生成されます -->
          </div>
        </div>

        <!-- クリアボタン -->
        <button id="clear-btn"
          class="px-6 py-3 bg-red-500 text-white font-bold rounded-lg hover:bg-red-600 transition duration-150 shadow-md flex-shrink-0 h-full sm:h-auto mt-auto">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-2" viewBox="0 0 20 20"
            fill="currentColor">
            <path fill-rule="evenodd"
              d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z"
              clip-rule="evenodd" />
          </svg>
          クリア
        </button>
      </div>
    </div>

    <!-- メインエリア: ドット絵と変換ボタン -->
    <div class="flex flex-col lg:flex-row lg:space-x-6 mt-6">

      <!-- ドット絵キャンバス -->
      <div class="lg:w-1/2 w-full mb-6 lg:mb-0">
        <h2 class="text-xl font-semibold mb-3 text-gray-700">ドット絵を描く</h2>
        <!-- グリッドコンテナ。ここでドット絵を描画 -->
        <div id="dot-grid-container" class="dot-grid w-full shadow-lg rounded-lg overflow-hidden">
          <!-- JavaScriptによってドットセルがここに挿入されます -->
        </div>
      </div>

      <!-- 変換結果とボタン -->
      <div class="lg:w-1/2 w-full space-y-4">
        <button id="convert-btn"
          class="w-full px-6 py-3 bg-green-600 text-white text-xl font-bold rounded-lg hover:bg-green-700 transition duration-150 shadow-lg transform hover:scale-[1.01] active:scale-[0.99]">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2" fill="none" viewBox="0 0 24 24"
            stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round"
              d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0l3-3m-3 3l3 3m7.418 4h.582m-15.356-2a8.001 8.001 0 0015.356-2m0 0l-3 3m3-3l-3-3" />
          </svg>
          配列に変換
        </button>

        <h2 class="text-xl font-semibold text-gray-700 pt-2">変換結果 (JavaScript配列)</h2>
        <div class="relative">
          <textarea id="array-output" rows="10" readonly
            class="w-full p-3 border border-gray-300 rounded-lg bg-gray-50 font-mono text-sm resize-none"></textarea>
          <button id="copy-btn"
            class="absolute top-2 right-2 p-2 bg-blue-500 text-white rounded-lg text-xs hover:bg-blue-600 transition duration-150"
            title="クリップボードにコピー">
            コピー
          </button>
        </div>

        <div id="message-box" class="hidden text-sm p-3 rounded-lg text-center transition duration-300" role="alert">
        </div>
      </div>
    </div>

  </div>

  <script>
    // DOM要素の取得
    const gridContainer = document.getElementById('dot-grid-container');
    const gridSizeInput = document.getElementById('grid-size');
    const setSizeBtn = document.getElementById('set-size-btn');
    const clearBtn = document.getElementById('clear-btn');
    const convertBtn = document.getElementById('convert-btn');
    const arrayOutput = document.getElementById('array-output');
    const copyBtn = document.getElementById('copy-btn');
    const messageBox = document.getElementById('message-box');
    const colorControlsContainer = document.getElementById('color-controls');
    
    let gridSize = parseInt(gridSizeInput.value, 10);
    let isDrawing = false; // ドラッグ描画判定用
    let drawState = 1;     // 描画モード (0:消しゴム, 1, 2, 3:色インデックス)

    // 各色インデックスに対応する、配列に出力するカスタム値（トークン）
    // key: colorIndex (0, 1, 2, 3...), value: 出力文字列
    let colorTokens = {
      '0': 0, // 色0 (消しゴム/背景) はデフォルトで 0
      '1': 1, // 色1 (黒) はデフォルトで 1
      '2': 2, // 色2 (赤) はデフォルトで 2
      '3': 3  // 色3 (青) はデフォルトで 3
    };

    // 定義済みの色とタイトル
    const predefinedColors = [
      { index: 0, title: "色0 (消しゴム/背景)", class: "bg-gray-100", style: "border: 2px solid #ccc;" },
      { index: 1, title: "色1 (黒)", class: "bg-gray-900", style: "" },
      { index: 2, title: "色2 (赤)", class: "bg-red-500", style: "" },
      { index: 3, title: "色3 (青)", class: "bg-blue-500", style: "" }
      // 必要に応じて色を増やす場合はここに定義を追加してください
    ];

    // メッセージボックスを表示する関数
    function showMessage(text, type = 'success') {
      messageBox.textContent = text;
      messageBox.className = `block text-sm p-3 rounded-lg text-center mt-4 transition duration-300`;

      if (type === 'success') {
        messageBox.classList.add('bg-green-100', 'text-green-800');
      } else if (type === 'error') {
        messageBox.classList.add('bg-red-100', 'text-red-800');
      } else {
        messageBox.classList.add('bg-gray-100', 'text-gray-800');
      }

      // 3秒後にメッセージを非表示にする
      setTimeout(() => {
        messageBox.classList.add('hidden');
        messageBox.className = `hidden text-sm p-3 rounded-lg text-center transition duration-300`;
      }, 3000);
    }

    // --- コントロールパネルの描画 ---

    /**
     * 色の選択ボタンと値入力フィールドを動的に描画する
     */
    function renderColorControls() {
      colorControlsContainer.innerHTML = '';
      
      predefinedColors.forEach(color => {
        const index = color.index;
        const colorDiv = document.createElement('div');
        colorDiv.classList.add('flex', 'items-center', 'space-x-3', 'p-2', 'rounded-lg', 'border');

        // 1. 色選択ボタン
        const colorBtn = document.createElement('button');
        colorBtn.dataset.color = index;
        colorBtn.classList.add(
          'color-btn', 
          'w-10', 'h-10', 
          color.class, 
          'rounded-full', 
          'focus:outline-none', 
          'focus:ring-4', 'focus:ring-offset-2', 
          'transition', 'duration-150',
          (index === 0 ? 'focus:ring-gray-300' : 'focus:ring-gray-900')
        );
        colorBtn.style.cssText = color.style;
        colorBtn.title = color.title;
        colorBtn.addEventListener('click', handleColorSelect);
        
        // 2. ラベルとタイトル
        const label = document.createElement('span');
        label.classList.add('text-sm', 'font-medium', 'text-gray-700', 'w-1/4', 'sm:w-1/5', 'flex-shrink-0');
        label.textContent = color.title.split(' ')[0]; // 例: "色1"

        // 3. 値入力フィールド
        const input = document.createElement('input');
        input.type = 'text';
        input.value = colorTokens[index]; // 現在の設定値を表示
        input.dataset.color = index;
        input.placeholder = index;
        input.classList.add(
          'token-input', 
          'flex-grow', 
          'p-1', 
          'border', 'border-gray-300', 
          'rounded-lg', 
          'text-center', 
          'font-mono', 
          'text-sm', 
          'focus:ring-blue-500', 
          'focus:border-blue-500'
        );

        // 値変更時のイベントリスナー
        input.addEventListener('input', (e) => {
          // colorTokensを更新
          // 値が数値で構成されているか、クォーテーションで囲むべき文字列かを判定
          const value = e.target.value.trim();
          
          if (value === "") {
             // 空文字列はそのまま保存
             colorTokens[index] = "";
          } else if (!isNaN(Number(value)) && isFinite(value) && value.indexOf('.') === -1) {
            // 整数と見なせる場合は数値として保存 (クォーテーションなし)
            colorTokens[index] = Number(value);
          } else if (value.match(/^[a-zA-Z0-9_]+$/)) {
            // クォーテーションなしで出力したい、例えばAやBなどの識別子の場合
             colorTokens[index] = value;
          } else {
            // それ以外（例: "A" や 'B' や float）は文字列として保存
             colorTokens[index] = value;
          }

          // 配列出力時に、クォーテーションで囲むかどうかは convertGridToArray で処理されます
        });

        colorDiv.appendChild(colorBtn);
        colorDiv.appendChild(label);
        colorDiv.appendChild(input);
        colorControlsContainer.appendChild(colorDiv);
      });

      // 初期選択状態のスタイルを適用
      updateColorButtonStyles(drawState);
    }

    /**
     * 色選択ボタンがクリックされた時の処理
     */
    function handleColorSelect(e) {
      // drawStateを更新
      drawState = parseInt(e.currentTarget.dataset.color, 10);
      
      // 選択状態のスタイルを更新
      updateColorButtonStyles(drawState);

      if (drawState === 0) {
        showMessage('描画色を 色 0 (消しゴム) に設定しました。');
      } else {
        showMessage(`描画色を 色 ${drawState} に設定しました。`);
      }
    }

    /**
     * 選択されている色ボタンのスタイルを更新する
     * @param {number} selectedIndex 選択された色インデックス
     */
    function updateColorButtonStyles(selectedIndex) {
      document.querySelectorAll('.color-btn').forEach(btn => {
        btn.classList.remove('border-4', 'border-gray-900', 'border-gray-300', 'ring-offset-2');
        
        const index = parseInt(btn.dataset.color, 10);
        if (index === selectedIndex) {
          // 選択状態のスタイルを適用
          if (selectedIndex === 0) {
            btn.classList.add('border-4', 'border-gray-300', 'ring-offset-2');
          } else {
            btn.classList.add('border-4', 'border-gray-900', 'ring-offset-2');
          }
        }
      });
    }

    // --- グリッド操作ロジック ---

    /**
     * 指定されたサイズでグリッドを再描画する
     * @param {number} size グリッドの辺の長さ
     */
    function renderGrid(size) {
      gridContainer.innerHTML = '';
      gridSize = size;
      // グリッドの列数を設定
      gridContainer.style.gridTemplateColumns = `repeat(${size}, 1fr)`;

      for (let i = 0; i < size * size; i++) {
        const cell = document.createElement('div');
        cell.classList.add('dot-cell');
        cell.dataset.index = i; // インデックスをデータ属性として保持
        // 初期色を0に設定
        cell.dataset.color = '0';
        gridContainer.appendChild(cell);
      }
    }

    /**
     * セルを指定された色インデックスに設定する
     * @param {HTMLElement} cell 操作対象のセル
     * @param {number} colorIndex 設定する色インデックス (0, 1, 2, 3...)
     */
    function setCellColor(cell, colorIndex) {
      cell.dataset.color = colorIndex;
    }

    // --- イベントハンドラ ---

    // グリッドサイズ変更ボタン
    setSizeBtn.addEventListener('click', () => {
      const newSize = parseInt(gridSizeInput.value, 10);
      if (newSize >= 4 && newSize <= 32) {
        renderGrid(newSize);
        showMessage(`グリッドサイズを ${newSize}x${newSize} に変更しました。`, 'info');
      } else {
        showMessage('サイズは4から32の間に設定してください。', 'error');
      }
    });

    // クリアボタン
    clearBtn.addEventListener('click', () => {
      document.querySelectorAll('.dot-cell').forEach(cell => {
        // すべてのセルを色0 (背景) に設定
        cell.dataset.color = '0';
      });
      arrayOutput.value = '';
      showMessage('キャンバスをクリアしました。', 'info');
    });

    // マウスダウン（描画開始）
    gridContainer.addEventListener('mousedown', (e) => {
      if (e.target.classList.contains('dot-cell')) {
        isDrawing = true;
        // 現在選択されている色インデックスで描画を開始
        setCellColor(e.target, drawState);
      }
    });

    // マウスアップ（描画終了）
    document.addEventListener('mouseup', () => {
      isDrawing = false;
    });

    // マウスオーバー（ドラッグ描画）
    gridContainer.addEventListener('mouseover', (e) => {
      if (isDrawing && e.target.classList.contains('dot-cell')) {
        // 現在選択されている色インデックスで描画を継続
        setCellColor(e.target, drawState);
      }
    });

    // タッチ操作のサポート (タッチスタートで描画開始、ムーブで描画継続)
    gridContainer.addEventListener('touchstart', (e) => {
      e.preventDefault(); // スクロールを防ぐ
      if (e.target.classList.contains('dot-cell')) {
        isDrawing = true;
        const touch = e.touches[0];
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        if (target && target.classList.contains('dot-cell')) {
          setCellColor(target, drawState);
        }
      }
    }, { passive: false });

    gridContainer.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (isDrawing) {
        const touch = e.touches[0];
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        if (target && target.classList.contains('dot-cell')) {
          setCellColor(target, drawState);
        }
      }
    }, { passive: false });

    document.addEventListener('touchend', () => {
      isDrawing = false;
    });


    // --- 変換ロジック ---

    /**
     * グリッドに保存されている色インデックスに対応するカスタム値を二次元配列に変換する
     * @returns {Array} 二次元配列の各要素はカスタム値（数値または文字列）
     */
    function convertGridToArray() {
      const cells = document.querySelectorAll('.dot-cell');
      const result = [];

      for (let i = 0; i < gridSize; i++) {
        const row = [];
        for (let j = 0; j < gridSize; j++) {
          const index = i * gridSize + j;
          const cell = cells[index];

          // data-color属性から色インデックス (0, 1, 2, 3...) を取得
          const colorIndex = cell.dataset.color;
          
          // 色インデックスに対応するカスタムトークンを取得
          let token = colorTokens[colorIndex];
          
          // tokenが数値かどうかをチェックし、そうでない場合は文字列として扱う
          // isNaN(token) は 'A' のような文字列でも true を返す
          // 数値かつ有限値の場合は、そのまま row に push 
          if (typeof token === 'number') {
            row.push(token);
          } else {
            // 文字列の場合は、出力時にクォーテーションで囲む
            row.push(`${token}`);
          }
        }
        result.push(row);
      }
      return result;
    }

    // 配列に変換ボタン
    convertBtn.addEventListener('click', () => {
      const array = convertGridToArray();

      // 新しいフォーマットロジック:
      // 1. 各行(内部配列)を文字列化: "[1, "A", 0, 2, ...]" (数字/文字列間にスペースを入れ見やすくする)
      // 2. それらをカンマと改行で結合: "[\n [row1], \n [row2], \n ... \n]"
      const rowStrings = array.map(row =>
        `[${row.join(', ')}]`
      );

      const outputString = `[\n  ${rowStrings.join(',\n  ')}\n]`;

      arrayOutput.value = `const dotArt = ${outputString};`;
      showMessage('ドット絵を二次元配列に変換しました！カスタム値が適用されています。');
    });

    // コピーボタン
    copyBtn.addEventListener('click', () => {
      if (arrayOutput.value) {
        // document.execCommand('copy')を使用してクリップボードにコピー
        arrayOutput.select();
        try {
          document.execCommand('copy');
          showMessage('配列をクリップボードにコピーしました。');
        } catch (err) {
          console.error('コピー失敗:', err);
          showMessage('コピーに失敗しました。手動でコピーしてください。', 'error');
        }
      } else {
        showMessage('最初に「配列に変換」ボタンを押してください。', 'error');
      }
    });

    // 初期化
    document.addEventListener('DOMContentLoaded', () => {
      renderGrid(gridSize);
      renderColorControls();
      // drawStateの初期選択に合わせてスタイルを適用
      updateColorButtonStyles(drawState);
    });
  </script>
</body>

</html>